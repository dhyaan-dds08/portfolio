

# Mobile Terminal - Build Command Interface

Interactive terminal for simulating mobile app builds with persistent history and platform-specific workflows. Demonstrates state management, local storage, and authentic CLI experience.

**Tech Stack**  
Flutter: 3.38.5 | State: Provider (ChangeNotifier) | Storage: Hive CE | Route: `/mobile` (dialog overlay)

**Dependencies:**
- `google_fonts: ^6.1.0` - Courier Prime monospace font
- `provider: ^6.1.5+1` - State management
- `hive_ce: ^2.15.1` - NoSQL local database
- `json_annotation: ^4.9.0` - JSON serialization annotations
- `json_serializable: ^6.11.3` - Code generation for JSON
- `build_runner: ^2.10.4` - Build-time code generation
- `path_provider: ^2.1.5` - Platform-specific storage paths

---

## Architecture

### State Management Pattern

**Provider + ChangeNotifier**

```dart
class TerminalState extends ChangeNotifier {
  BuildState _buildState = BuildState.idle;
  List<FrontendCommandHistory> _sessionHistory = [];
  late Box _historyBox;
  
  void saveCommand(String cmd, String output, bool success) {
    // Save to Hive + session
    _historyBox.put(timestamp, history.toJson());
    _sessionHistory.add(history);
    notifyListeners(); // Reactive UI update
  }
}
```

**Why Provider?**
- Built into Flutter ecosystem
- Simple mental model (listen → notify)
- No boilerplate (vs BLoC/Redux)
- Efficient rebuilds with `Consumer<T>`

**Why ChangeNotifier?**
- Reactive updates without setState()
- Centralized state logic
- Testable (mock/inject easily)
- Memory efficient (auto-dispose)

---

### Data Persistence

**Hive CE + JSON Serialization**

```dart
@JsonSerializable()
class FrontendCommandHistory {
  final String command;
  final DateTime timestamp;
  final String? output;
  final bool success;
  
  // Auto-generated by build_runner
  factory FrontendCommandHistory.fromJson(Map<String, dynamic> json) =>
      _$FrontendCommandHistoryFromJson(json);
  Map<String, dynamic> toJson() => _$FrontendCommandHistoryToJson(this);
}
```

**Why Hive CE?**
- NoSQL key-value store (fast reads/writes)
- No code generation required (vs Hive classic)
- Web support (IndexedDB backend)
- Type-safe with JSON serialization
- 2.15.1+ removes `@HiveType` annotations

**Storage Strategy:**
- **Persistent** - All commands saved to `frontendCommandHistory` box
- **Session-based** - Only current session visible in UI
- **Dual-access** - Up arrow retrieves all history, display shows session only

**Platform Handling:**
```dart
void main() async {
  if (!kIsWeb) {
    Hive.init('hive_data'); // Mobile/desktop: local directory
  }
  // Web: IndexedDB automatic (no init needed)
  await Hive.openBox('frontendCommandHistory');
}
```

---

## UI Architecture

### Terminal Window Structure

**StatefulWidget + Controllers**

```dart
class _MobileTerminalScreenState extends State<MobileTerminalScreen> {
  final TextEditingController _commandController;  // Input field
  final FocusNode _commandFocusNode;              // Auto-focus
  final ScrollController _scrollController;        // Auto-scroll
  
  @override
  void initState() {
    context.read<TerminalState>().initializeHive();
    _commandFocusNode.requestFocus(); // Terminal ready immediately
  }
}
```

**Why StatefulWidget?**
- Controllers need initState/dispose lifecycle
- Focus management (click anywhere → focus input)
- Scroll position tracking (auto-scroll to bottom)

**Why Controllers?**
- `TextEditingController` - Command input state
- `FocusNode` - Keyboard focus management (click-to-focus)
- `ScrollController` - Programmatic scroll (new command → bottom)

---

### Build State Machine

**Four States, Clean Transitions**

```dart
enum BuildState { idle, building, complete, simulatorReady }

Consumer<TerminalState>(
  builder: (context, state, child) {
    switch (state.buildState) {
      case BuildState.idle:        return _buildIdleState();
      case BuildState.building:    return _buildBuildingState();
      case BuildState.complete:    return _buildCompleteState();
      case BuildState.simulatorReady: return _buildSimulatorState();
    }
  },
)
```

**State Flow:**
```
idle → [user clicks iOS/Android] → building (3s animation)
     → complete (2s success message) → simulatorReady (phone UI)
```

**Why State Machine?**
- Predictable transitions
- No invalid states
- Clear separation of concerns
- Easy to test/debug

---

## Command System

### Available Commands

```bash
flutter build ios --release    # iOS build simulation
flutter build apk --release    # Android build simulation
clear                          # Clear terminal + history
history                        # List all past commands
help                           # Show available commands
```

### Command Parsing

**Case-insensitive, Flexible Matching**

```dart
void _executeCommand(String command, TerminalState state) {
  final cmd = command.trim().toLowerCase();
  
  if (cmd.contains('flutter build ios') || cmd.contains('iphoneos')) {
    _startBuild('ios');
  } else if (cmd.contains('apk') || cmd.contains('android')) {
    _startBuild('android');
  } else if (cmd == 'clear' || cmd == 'cls') {
    state.clearHistory();
  }
  // ... more commands
}
```

**Why Flexible?**
- `flutter build ios` works
- `flutter build iphoneos` works
- `build ios` works
- User-friendly (not strict)

---

### History Navigation

**Dual-History System**

```dart
// UI displays session-only (fresh on open)
List<FrontendCommandHistory> getSessionHistory() {
  return _sessionHistory; // Empty when terminal opens
}

// Up/Down arrows access all history
List<FrontendCommandHistory> getAllCommandHistory() {
  return _historyBox.keys.map(/* parse from Hive */).toList();
}
```

**Keyboard Shortcuts:**
- **Up Arrow** - Previous command (from all history)
- **Down Arrow** - Next command (from all history)
- **Enter** - Execute command
- **Click anywhere** - Focus input

**Why Dual System?**
- Clean terminal on open (professional)
- Persistent history for productivity
- Best of both worlds

---

## Build Simulation

### Stage-by-Stage Animation

**iOS Build Process (12 stages, 6 seconds)**

```dart
Future<void> _simulateBuildProcess(TerminalState state) async {
  // Stage 1-2: Dependencies (20%)
  state.addLog('Running "flutter pub get"...');
  await Future.delayed(Duration(milliseconds: 500));
  state.addLog('✓ Dependencies resolved');
  state.updateProgress(0.2);
  
  // Stage 3-4: Platform-specific (40%)
  if (state.selectedPlatform == 'ios') {
    state.addLog('Analyzing dependencies...');
    state.addLog('✓ Pod install complete');
  }
  state.updateProgress(0.4);
  
  // Stage 5-8: Compilation, Linking, Signing (60% → 85%)
  state.addLog('○ Compiling Swift files...');
  state.updateProgress(0.6);
  await Future.delayed(Duration(milliseconds: 800));
  state.replaceLastLog('○', '✓'); // Checkmark animation
  
  // ... more stages
  
  // Stage 9-10: Complete (100%)
  state.completeBuild();        // Show success screen
  await Future.delayed(Duration(seconds: 2));
  state.launchSimulator();      // Show phone UI
}
```

**Progress Stages:**
- 0-20%: Dependencies
- 20-40%: Platform setup (CocoaPods/Gradle)
- 40-60%: Compilation
- 60-75%: Linking
- 75-85%: Code signing
- 85-100%: Bundle generation

**Visual Feedback:**
- `○` - In progress
- `✓` - Completed (animated transition)
- `✗` - Failed (if error)
- Progress bar (0-100%)

**Why Realistic?**
- Educational (shows real build steps)
- Professional aesthetic
- Demonstrates async state management
- Smooth animations (60fps)

---

## Rendering Strategy

### Selective Text

**Why SelectableText?**

```dart
Widget _buildTerminalText(String text, {Color? color}) {
  return SelectableText(
    text,
    style: GoogleFonts.courierPrime(
      color: color ?? Colors.white,
      fontSize: 13,
    ),
  );
}
```

**Benefits:**
- Copy/paste commands
- Select error messages
- Screen reader accessible
- Professional terminal feel

**Trade-off:**
- Slightly heavier than `Text`
- Worth it for UX

---

### Consumer Rebuilds

**Efficient Updates**

```dart
Consumer<TerminalState>(
  builder: (context, state, child) {
    // Only rebuilds when TerminalState.notifyListeners() called
    return _buildTerminalContent(state);
  },
)
```

**Why Consumer?**
- Granular rebuilds (only terminal, not entire app)
- No manual setState()
- Reactive to state changes
- Clean separation (UI ← State)

---

## Session Management

### Fresh Terminal on Open

**Session vs Persistent History**

```dart
void initializeHive() {
  _historyBox = Hive.box('frontendCommandHistory');
  _sessionHistory = []; // Start fresh
  notifyListeners();
}

// UI shows only session
List<FrontendCommandHistory> getSessionHistory() {
  return _sessionHistory; // Empty on open
}

// Up arrow shows all
List<FrontendCommandHistory> getAllCommandHistory() {
  return _historyBox.keys /* ... */; // All past sessions
}
```

**Flow:**
```
Terminal Opens
  ↓
Clean slate (no visible history)
  ↓
User types: flutter build ios
  ↓
Command added to session + Hive
  ↓
Visible in current terminal
  ↓
Terminal Closes
  ↓
Next Open: Clean again
  ↓
Up Arrow: Still shows old "flutter build ios"
```

**Why This Design?**
- Professional (fresh terminal)
- Productive (history accessible)
- Familiar (matches real terminals)

---

## Performance

### Memory Management

**No Leaks**

```dart
@override
void dispose() {
  _commandController.dispose();  // Release text input
  _commandFocusNode.dispose();   // Release focus node
  _scrollController.dispose();   // Release scroll position
  super.dispose();
}
```

**Why Critical?**
- Each controller = ~16KB
- Without dispose: 3 leaks per terminal open
- 10 opens = 480KB wasted
- Multiplied by all users

---

### Efficient Storage

**Hive CE Advantages:**
- Key-value store (not SQL overhead)
- Lazy loading (only read on demand)
- Compact binary format
- ~10KB for 100 commands

**Web Platform:**
- IndexedDB backend (browser native)
- No file I/O overhead
- Async by default

---

## Visual Design

### Color Palette

**VS Code Dark Theme**

```dart
const terminal = Color(0xFF1E1E1E);    // Background
const command = Color(0xFF4EC9B0);     // Cyan (commands)
const success = Colors.green;          // Success messages
const error = Colors.red;              // Error messages
const path = Colors.blue;              // File paths
const prompt = Colors.green;           // Username/prompt
```

**Typography:**
- Courier Prime (monospace)
- 13px body text
- Fixed-width for alignment

---

### Command History Cards

**Chat-Style Design**

```dart
Container(
  decoration: BoxDecoration(
    color: Color(0xFF252526),
    border: Border.all(
      color: success ? Colors.green.withOpacity(0.3)
                    : Colors.red.withOpacity(0.3),
    ),
  ),
  child: Column(
    children: [
      Row([Icon(success ? check : error), command, timestamp]),
      if (output != null) SelectableText(output),
    ],
  ),
)
```

**Why Cards?**
- Clear separation
- Status at a glance (border color)
- Timestamp context
- Professional aesthetic

---

## Key Decisions

| Choice | Alternative | Why |
|--------|-------------|-----|
| Provider | BLoC/Riverpod | Simple, built-in, sufficient |
| Hive CE | SharedPreferences | Type-safe, structured, scalable |
| JSON Serializable | Manual parsing | Type-safe, auto-generated, maintainable |
| Session + Persistent | Persistent only | Clean UI, productive UX |
| SelectableText | Text | Copy/paste, accessibility |
| ChangeNotifier | setState() | Centralized logic, testable |
| Consumer | StreamBuilder | Simpler, less boilerplate |
| StatefulWidget | StatelessWidget | Controllers need lifecycle |

---

## File Structure

```
lib/
├─ screens/mobile/
│  ├─ mobile_terminal_screen.dart    # UI layer (StatefulWidget)
│  └─ terminal_state.dart            # State layer (ChangeNotifier)
├─ models/
│  ├─ frontend_command_history.dart  # Data model
│  └─ frontend_command_history.g.dart # Auto-generated JSON
└─ widgets/
   └─ terminal_window.dart           # Reusable window chrome

assets/markdown/
└─ mobile_terminal.md                # This documentation
```

---

## Future Enhancements

**Planned:**
- Phone simulator UI (3D device frames)
- App icon grid (BigShorts + placeholders)
- Interactive app details (click to view)
- Screenshot carousel
- Tech stack visualization

**Under Consideration:**
- Command autocomplete (Tab key)
- Command aliases (`bi` = `build ios`)
- Export build logs
- Custom color themes
- Split-screen (iOS + Android)

---

## Learning Resources

**State Management:**
- [Provider Documentation](https://pub.dev/packages/provider)
- [ChangeNotifier Guide](https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html)

**Data Persistence:**
- [Hive CE Documentation](https://pub.dev/packages/hive_ce)
- [JSON Serialization](https://docs.flutter.dev/development/data-and-backend/json)

**Flutter Patterns:**
- [StatefulWidget Lifecycle](https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html)
- [Keyboard Handling](https://api.flutter.dev/flutter/widgets/RawKeyboardListener-class.html)


